<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <title>Measurement</title>
   
    {% load static %}
    <link rel="stylesheet" href="{% static 'css/measurements.css'%}">
    
</head>
<body>
    <div class="notify" style="display: none;"></div>

    <div id="loading_spinner" style="display: none;">
        <i class="fas fa-spinner fa-spin"></i> 
    </div>
    <div class="container-1">
        <div class="container-1-1">
            <button type="submit" id="menu_btn">
                <i class="fas fa-bars" id="menu_icon"></i>[F12]
            </button>
            <input type="text" id="date_time" >
            <input type="text" id="operator" >
            <input type="text" id="shift" class="shift-name">
            <input type="text" id="message">
            <button type="submit" id="exit_btn">
                <i class="fas fa-sign-out-alt" id="exit_icon"></i>
            </button>
        </div>
        <div class="container-1-2">
            <label for="part_model">PART MODEL:</label>
            <input type="text" id="part_model">

            <label for="part_no" style="margin-left: 1%;">PART NAME:</label>
            <input type="text" id="part_no" >

            <label for="part_status" style="margin-left: 2%;">PART STATUS:</label>
            <input type="text" id="accept">
            <input type="text" id="rework">
            <input type="text" id="reject">
            <input type="text" id="total">
        </div>
        <div class="container-1-3">
            <input type="text" id="notification_bar">
            <input type="text" id="overall_status" >
        </div>

    </div>

<!--//////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->


    <div class="container-2">
        <div class="gauge-container" id="gauge1">
            <input type="text" id="para_name1" class="input-box" />
            <!-- <div class="input-row-top">
                <input type="text" id="lsl_1" class="input-box1-top" />
                <input type="text" id="nominal_1" class="input-box1-top"  />
                <input type="text" id="usl_1" class="input-box1-top"  />
            </div> -->
            <canvas id="gaugeCanvas1" width="450" height="330"></canvas>
            <!-- First row: Labels -->
            <!-- <div class="label-row">
                <label for="max">MAX</label>
                <label for="min">MIN</label>
                <label for="tir">TIR</label>
            </div> -->

            <!-- Second row: Input boxes -->
            <!-- <div class="input-row">
                <input type="text" id="max1" class="input-box1"  />
                <input type="text" id="min1" class="input-box1"  />
                <input type="text" id="tir1" class="input-box1"  />
            </div> -->
        </div>
        <div class="gauge-container" id="gauge2">
            <input type="text" id="para_name2" class="input-box" />
            <!-- <div class="input-row-top">
                <input type="text" id="lsl_2" class="input-box1-top"  />
                <input type="text" id="nominal_2" class="input-box1-top"  />
                <input type="text" id="usl_2" class="input-box1-top"  />
            </div> -->
            <canvas id="gaugeCanvas2" width="450" height="330"></canvas>
            <!-- First row: Labels -->
            <!-- <div class="label-row">
                <label for="max">MAX</label>
                <label for="min">MIN</label>
                <label for="tir">TIR</label>
            </div> -->

            <!-- Second row: Input boxes -->
            <!-- <div class="input-row">
                <input type="text" id="max2" class="input-box1"  />
                <input type="text" id="min2" class="input-box1"  />
                <input type="text" id="tir2" class="input-box1"  />
            </div> -->
        </div>

        
        <div class="angle_readings" id="angle">
            <label for="angle" style="background-color: aqua;">ANGLE VALUE:</label><br>
            <input type="text" id="angleInput">
        </div>
    </div>

<!--//////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

    <div class="container-3">
        <div class="container-3-1">
            <label for="punch_no">PUNCH NO:</label>
            <input type="text" id="punch_no">

            <div>
               <textarea id="probe-A"></textarea>
               <textarea id="probe-B"></textarea>
                <textarea id="probe-C"></textarea>
               <textarea id="probe-D"></textarea>
            </div>
            <button id="rest-btn" class="toggle-btn" disabled style="filter: blur(2px);">START[F4]<br>STOP[F5]</button>

        </div>
       
        <div class="container-3-2">
           

            <button type="submit" class="container-3-2-btn" id="master_btn">MASTERING[F1]</button>
            <button type="submit" class="container-3-2-btn" id="model_btn" onclick="showNextPartName()">MODEL[F2]</button>
            <button type="submit" class="container-3-2-btn" id="spc_btn">SPC[F3]</button>
            <button type="submit" class="container-3-2-btn" id="report_btn">REPORT[F6]</button>

           
        </div>

        <div id="punch_overwrite" class="center-notification">
            <div id="punch_overwrite_container">
                <p id="error_message"></p>
                <p>Do you want to OVERWRITE</p>
                <button id="overwrite_cancel_button" onclick="punchOverwriteCancel()">CANCEL</button>
                <button id="overwrite_ok_button" onclick="punchOverwrite()">OK</button>
            </div>
            <div id="punch_overwrite_credentials">
                <label for="userid_punch">USER ID:</label>
                <input type="text" id="userid_punch" class="userpassinput1"><br>
                <label for="password_punch">PASSWORD:</label>
                <input type="text" id="password_punch" class="userpassinput"><br><br>
                <button id="punch_login" onclick="punchOverwriteLogin()">OK</button>
                </div>
        </div>


        </div>
    
        <input type="text" id="db_port" value="{{ comport_com_port }}" hidden>
        <input type="text" id="com_ports" value="{{ ports_string }}" hidden>
        <input type="text" id="baud_rate" value="{{ comport_baud_rate }}" hidden>
        <input type="text" id="parity" value="{{ comport_parity }}" hidden>
        <input type="text" id="stopbit" value="{{ comport_stopbit }}" hidden>
        <input type="text" id="databit" value="{{ comport_databit }}" hidden>
        <textarea id="serial-data-display" cols="50" rows="10" readonly hidden></textarea>  
   
   
<script>


window.addEventListener('DOMContentLoaded', (event) => {
            var inputs = document.querySelectorAll('input');
            inputs.forEach(input => {
                input.setAttribute('autocomplete', 'off');
            });

        });
document.addEventListener('keydown', function(event) {
        // Check for specific function keys
        switch (event.key) {
            case 'F1':
                event.preventDefault(); // Prevent default action
                document.getElementById('master_btn').click(); // Trigger Add New button
                break;
            case 'F2':
                event.preventDefault(); // Prevent default action
                document.getElementById('model_btn').click(); // Trigger Save button
                break;
            case 'F3':
                event.preventDefault(); // Prevent default action
                document.getElementById('spc_btn').click(); // Trigger Delete button
                break;
            case 'F6':
                event.preventDefault(); // Prevent default action
                document.getElementById('report_btn').click(); // Trigger Cancel button
                break;


            case 'F12':
                event.preventDefault(); // Prevent default action
                document.getElementById('menu_btn').click(); // Trigger Cancel button
                break;    
        }
    });



    document.addEventListener("DOMContentLoaded", function () {
            // Get the username passed from the backend
            let receivedUserName = "{{ username|safe }}";
            console.log('Your receivedUserName is:', receivedUserName);

            // Get the button element
            const menuButton = document.getElementById("menu_btn");

            // Add a click event listener to the button
            menuButton.addEventListener("click", function (event) {
                // Check if the username is SAADMIN
                if (receivedUserName === "SAADMIN") {
                    // Redirect to the comport page
                    window.location.href = "{% url 'comport' %}";
                } else {
                    // Show an alert message and prevent redirection
                    event.preventDefault();
                    alert("You are not authorized to access this page.");
                }
            });
        });

    document.getElementById("exit_btn").addEventListener("click", function() {
        // Redirect to the measurement URL
        window.location.href = "{% url 'login' %}";
    });
    


$(document).ready(function () {
    // Delay the execution by 2 seconds
    setTimeout(function () {
        // Get the input values
        var dateTime = $("#date_time").val(); // Example: 21/12/2024 6:53:57 PM
        console.log('Original value:', dateTime);

        // Convert the original format to Date object
        var dateParts = dateTime.split(' ');
        var date = dateParts[0].split('/');
        var time = dateParts[1].split(':');
        var ampm = dateParts[2];
        
        // Convert to 12-hour format (adjust time to 12-hour clock)
        var hours = parseInt(time[0]);
        if (ampm === 'PM' && hours < 12) {
            hours += 12; // Convert PM hours to 24-hour format
        }
        if (ampm === 'AM' && hours === 12) {
            hours = 0; // Convert 12 AM to 0 (midnight)
        }

        // Construct Date object with the corrected time
        var formattedDate = new Date(date[2], date[1] - 1, date[0], hours, time[1], time[2]);

        // Format the date to "yyyy/mm/dd hh:mm:ss AM/PM"
        var year = formattedDate.getFullYear();
        var month = (formattedDate.getMonth() + 1).toString().padStart(2, '0'); // Add leading zero if needed
        var day = formattedDate.getDate().toString().padStart(2, '0'); // Add leading zero if needed
        var hours12 = formattedDate.getHours() % 12 || 12; // 12-hour format
        var minutes = formattedDate.getMinutes().toString().padStart(2, '0');
        var seconds = formattedDate.getSeconds().toString().padStart(2, '0');
        var period = (formattedDate.getHours() >= 12) ? 'PM' : 'AM';

        var formattedDateTime = `${year}/${month}/${day} ${hours12}:${minutes}:${seconds} ${period}`;
        console.log('Formatted value to send:', formattedDateTime);

        var shift = $("#shift").val(); // Example: SHIFT-2

        // Send AJAX GET request
        $.ajax({
            url: '/measurement_count/', // Replace this with your actual endpoint
            type: 'POST',
            data: { 
                date: formattedDateTime, 
                shift: shift 
            },
            success: function (response) {
                console.log("Data received successfully:");
                console.log("Accept Last Occurrence:", response.accept_occurrence);
                console.log("Reject Last Occurrence:", response.reject_occurrence);
                console.log("Rework Last Occurrence:", response.rework_occurrence);
                console.log("Total Occurrence:", response.total_occurrence);

                // Display the values in the input fields
                $('#accept').val(response.accept_occurrence);
                $('#reject').val(response.reject_occurrence);
                $('#rework').val(response.rework_occurrence);
                $('#total').val(response.total_occurrence);
            },
            error: function (error) {
                console.log("Error:", error);
            },
        });
    }, 2000); // Delay of 2000 milliseconds (2 seconds)
});



// Initialize the list of part names and the current index
        let receivedValue = "{{ part_model|safe }}";
        console.log('your part_model is:',receivedValue);
        let partNames = receivedValue
            .replace(/[\[\]' ]/g, '') // Remove [, ], ', and spaces
            .split(','); // Split by comma to get an array

        let currentIndex = 1; // Start with the first part name

       // Function to update the part model and call sendPartModelToBackend
function showNextPartName() {
    if (partNames.length > 0) {
        const partModel = partNames[currentIndex];
        // Update the input field with the current part model
        document.getElementById('part_model').value = partModel;

        // Send the updated part model to the backend
        sendPartModelToBackend(partModel);

        // Increment the index and loop back to the start if needed
        currentIndex = (currentIndex + 1) % partNames.length;
    } else {
        // Handle no part names case
        alert("No part names available.");
    }
}

// Initialize the part model input on page load and send the initial value
$(document).ready(function () {
    if (partNames.length > 0) {
        // Initialize the input box with the first part name
        const initialPartModel = partNames[0];
        $('#part_model').val(initialPartModel);

        // Send the initial part model to the backend
        console.log("Initial partModel sent to the backend:", initialPartModel);
        sendPartModelToBackend(initialPartModel);
    } else {
        console.warn("No part names available on page load.");
    }
});

        // Initialize the input box on page load
        window.onload = function () {
            if (partNames.length > 0) {
                document.getElementById('part_model').value = partNames[0];
            }
        };
/////////////////////////////////////////////////////////////////





// Global object to store the response data for future use
let responseData = {};


// Global variable to store the total number of steps
let totalSteps ;

// Function to send the part model to the backend and store the response data
function sendPartModelToBackend(partModel) {
    console.log("Sending updated partModel to backend:", partModel);

    $.ajax({
        url: '/measurement/', // Replace with your backend endpoint
        method: 'POST',
        data: { part_model: partModel },
        success: function (response) {
            console.log("part_name_value:", response.part_name_value);
            console.log("char_lock_value:", response.char_lock_value);
            console.log("char_lock_limit_value:", response.char_lock_limit_value);
            console.log("punch_no_value:", response.punch_no_value);


            const restButton = document.getElementById('rest-btn'); // Get the button element


            if (response.punch_no_value === true) {
                const punchNoField = document.getElementById('punch_no');
                if (punchNoField) {
                    punchNoField.disabled = false; // Ensure the field is enabled
                    punchNoField.style.filter = 'none'; // Remove blur effect
                    punchNoField.focus(); // Focus on the input field

                    if (restButton) {
                        restButton.disabled = true; // Disable the button
                        restButton.style.filter = 'blur(2px)'; // Apply blur effect
                    }
                    
                }

                // Listen for "Enter" key press
                // Listen for "Enter" key press
                punchNoField.addEventListener('keydown', function (event) {
                    if (event.key === 'Enter') {
                        const inputValue = punchNoField.value;
                        const charLockValue = response.char_lock_value;
                        const charLockLimitValue = response.char_lock_limit_value;
                        const partModel = document.getElementById('part_model').value; // Get part_model

                        

                        // Validation checks for input value
                        if (!inputValue.startsWith(charLockValue)) {
                            alert(`Input must start with ${charLockValue}`);
                            punchNoField.value = '';
                            return;
                        }

                        const expectedLength = Number(charLockLimitValue);
                        if (inputValue.length !== expectedLength) {
                            alert(`Input must be exactly ${expectedLength} characters long.`);
                            punchNoField.value = '';
                            return;
                        }

                        // Re-enable and remove blur effect from the rest button
                        if (restButton) {
                            restButton.disabled = false; // Enable the button
                            restButton.style.filter = 'none'; // Remove blur effect
                        }

                        // Step 1: Send POST request to check if the punch number exists
                        fetch('/delete_measure_data/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCSRFToken()
                            },
                            body: JSON.stringify({ input_value: inputValue, part_model: partModel }) // Send part_model and comp_sr_no
                        })
                        .then(response => response.json()) // Ensure the response is JSON
                        .then(data => {
                            if (data.status === 'exists') {
                                // Step 2: Show overwrite confirmation popup
                                document.getElementById('error_message').innerText = data.message;
                                document.getElementById('punch_overwrite').style.display = 'block';

                                // Handle OK button click
                                document.getElementById('overwrite_ok_button').onclick = function () {
                                    document.getElementById('punch_overwrite_container').style.display = 'none';
                                    // Show credentials input field
                                    document.getElementById('punch_overwrite_credentials').style.display = 'block';
                                };

                                // Handle Cancel button click
                                document.getElementById('overwrite_cancel_button').onclick = function () {
                                    document.getElementById('punch_overwrite').style.display = 'none';
                                    location.reload();
                                };

                                // Step 3: Handle deletion with credentials
                                document.getElementById('punch_login').onclick = function () {
                                    const userId = document.getElementById('userid_punch').value; // Get user ID from input field
                                    const password = document.getElementById('password_punch').value; // Get password from input field

                                    // Validate credentials before posting
                                    if (userId !== 'admin' || password !== 'admin') {
                                        alert('Invalid credentials. Please check username and password.');
                                        return;
                                    }
                                    localStorage.setItem('punchValue', inputValue);
                                    // Send delete request with credentials
                                    fetch('/delete_measure_data/', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                            'X-CSRFToken': getCSRFToken()
                                        },
                                        body: JSON.stringify({
                                            input_value: inputValue,
                                            part_model: partModel,
                                            user_id: userId,
                                            password: password
                                        })
                                    })
                                    .then(response => response.json())
                                    .then(deleteData => {
                                        alert(deleteData.message); // Show success/error message
                                        location.reload();
                                        if (deleteData.success) {
                                            document.getElementById('punch_overwrite').style.display = 'none';
                                            $('#punch_overwrite').hide();
                                            
                                        }
                                    })
                                    .catch(error => {
                                        console.error('Error:', error);
                                        alert('Failed to delete punch number.');
                                    });
                                };
                            }
                            //  else {
                            //     // Keep the button disabled and blurred if 'punch_no_value' is false
                            //     $('#rest-btn').prop('disabled', false).css('filter', 'none');
                            // }
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            alert('Failed to process punch number.');
                        });
                    }
                });


                


            } 
            else {
                // Keep the button disabled and blurred if 'punch_no_value' is false
               // $('#rest-btn').prop('disabled', false).css('filter', 'none');
                const punchNoField = document.getElementById('punch_no');
                if (punchNoField) {
                    punchNoField.disabled = true; // Disable the field
                    punchNoField.style.filter = 'blur(2px)'; // Apply blur effect
                }

                if (restButton) {
                    restButton.disabled = false;
                    restButton.style.filter = 'none';
                }
            }
            // Display the 'part_name_value' in the input field with id 'part_no'
            $('#part_no').val(response.part_name_value);

            // Update the global responseData object
            responseData = {
                partNameValue: response.part_name_value,
                charLockValue: response.char_lock_value,
                charLockLimitValue: response.char_lock_limit_value,
                angle: response.angle,
                punchNoValue: response.punch_no_value,
                parameterValues: response.parameter_values,
                parameterNameArray: response.parameter_name_array,
                channelNoArray: response.channel_no_array,
                lowMasterArray: response.low_master_array,
                highMasterArray: response.high_master_array,
                nominalArray: response.nominal_array,
                lslArray: response.lsl_array,
                uslArray: response.usl_array,
                ltlArray: response.ltl_array,
                utlArray: response.utl_array,
                stepNoArray: response.step_no_array,
                autoManArray: response.auto_man_array,
                timerArray: response.timer_array,
                digitsArray: response.digits_array,
            };

            console.log("Response Data:", responseData);

            // Update the global totalSteps variable
            const stepNo = response.step_no_array;
            totalSteps = Math.max(...stepNo); // Find the largest step number
            console.log("Number of Steps:", totalSteps);

            // Log the totalSteps after it has been updated
            console.log("Global totalSteps (after update):", totalSteps);

            // Iterate through the parameter values and display all fields for each parameter
            const parameterValues = response.parameter_values;
            console.log("Step No:", response.step_no_array);

           

            // Loop through response data and update the respective gauge elements
            for (let i = 0; i < response.parameter_name_array.length; i++) {
                // Update gauge-specific fields
                let gaugeIndex = i + 1; // Adjust to match the IDs (1-based indexing)

                // Update parameter name
                $('#para_name' + gaugeIndex).val(response.parameter_name_array[i]);
                $('#lsl_' + gaugeIndex).val(`LSL: ${response.lsl_array[i]}`).css('color', 'purple');
                $('#nominal_' + gaugeIndex).val(`NOM: ${response.nominal_array[i]}`);
                $('#usl_' + gaugeIndex).val(`USL: ${response.usl_array[i]}`).css('color', 'purple');
                // Call the `drawGauge` function and pass the nominal value for each gauge
                drawGauge(
                    'gaugeCanvas' + gaugeIndex,
                    response.nominal_array[i], // Nominal value
                    response.lsl_array[i],     // Lower specification limit (LSL)
                    response.usl_array[i],     // Upper specification limit (USL)
                    response.ltl_array[i],     // Lower tolerance limit (LTL)
                    response.utl_array[i]      // Upper tolerance limit (UTL)
                );
            }
        },
        error: function (xhr, status, error) {
            console.error('Error:', error);
        }
    });
}




document.addEventListener('DOMContentLoaded', function() {
    // Retrieve the punch value from localStorage
    var savedPunchValue = localStorage.getItem('punchValue');
    
    if (savedPunchValue) {
        // Set the punch value in the textarea
        document.getElementById('punch_no').value = savedPunchValue;
        
        // Clear the localStorage value to avoid persisting it across multiple reloads
        localStorage.removeItem('punchValue');
    }

    // Set focus on the punch_textarea
    document.getElementById('punch_no').focus();
});





function getCSRFToken() {
    const cookie = document.cookie.split('; ').find(row => row.startsWith('csrftoken='));
    return cookie ? cookie.split('=')[1] : '';
}



let displayOutputs = []; // Array to store displayOutput values for all steps
let currentStep = 1;     // Initialize the current step to 1
    // Example total steps (you can set this dynamically)

// Wait for the DOM content to load
document.addEventListener('DOMContentLoaded', () => {
    const button = document.getElementById('rest-btn');
    const notificationBar = document.getElementById('notification_bar');
    let isStart = true; // Tracks the current state of the button

    const handleAction = () => {
        if (isStart) {
            // Start action triggered
            console.log(`Start action triggered for Step ${currentStep}!`);
            notificationBar.value = `MEASUREMENT IS STARTING FOR STEP ${currentStep}`;

            button.innerHTML = `STOP[F5] - Step ${currentStep}`; // Update button text
            button.id = 'stop-btn'; // Change button ID

            // Call the function to start data collection for the current step
            getStoredData(currentStep);
            updateAngle();
           
        } else {
            // Stop action triggered
            console.log(`Stop action triggered for Step ${currentStep}!`);
            notificationBar.value = `MEASUREMENT IS COMPLETED FOR STEP ${currentStep}`;

            button.innerHTML = `START[F4] - Step ${currentStep + 1}`; // Update button text
            button.id = 'start-btn'; // Change button ID

            // Perform calculations for the current step
            calculateMaxMinTir();
            
            // Check if more steps remain
            if (currentStep < totalSteps) {
                currentStep++; // Move to the next step
            } else {
                console.log("All steps completed!");
                notificationBar.value = "YOU HAVE COMPLETED THE MEASUREMENT FOR THIS JOB. DO THE NEXT JOB.";
                button.innerHTML = "START[F4]"; // Reset to initial state
                currentStep = 1; // Reset the step to 1
            }
        }
        isStart = !isStart; // Toggle the state
    };

    // Add click event listener for the button
    button.addEventListener('click', handleAction);

    // Add keydown event listener for keyboard shortcuts
    document.addEventListener('keydown', (event) => {
        if (event.key === 'F4' && isStart) {
            event.preventDefault();
            
            // Trigger the start action if F4 is pressed and in start state
            handleAction();
        } else if (event.key === 'F5' && !isStart && currentStep === totalSteps) {
            event.preventDefault();
            
            // Trigger the stop action if F5 is pressed and in stop state
            handleAction();
            
        }
    });
});










function getStoredData(currentStep) {
    console.log("Stored Data :", responseData);

    const parameterValues = responseData.parameterValues;

    // Loop through the parameterNameArray to ensure we iterate properly
    for (let i = 0; i < responseData.parameterNameArray.length; i++) {
        const parameter = parameterValues[i];

        // Ensure parameter is not undefined and has the expected structure
        if (!parameter || typeof parameter !== 'object') {
            console.error(`Invalid parameter at index ${i}:`, parameter);
            continue; // Skip invalid parameters
        }

        // Extract values for displaySerialData
        const parameterName = responseData.parameterNameArray[i];
        const probeNumber = responseData.channelNoArray[i];
        const lowMaster = responseData.lowMasterArray[i];
        const highMaster = responseData.highMasterArray[i];
        const angle = responseData.angle[i];
        const lsl = responseData.lslArray[i];
        const usl = responseData.uslArray[i];
        const ltl = responseData.ltlArray[i];
        const utl = responseData.utlArray[i];
        const stepNo = responseData.stepNoArray[i];
        const autoMan = responseData.autoManArray[i];
        const timer = responseData.timerArray[i];
        const digits = responseData.digitsArray[i];

        // Ensure that e, d, and o1 values exist in the parameter
        const e_value = parameter.e || 0;  // Default to 0 if e_value is not found
        const d_value = parameter.d || 0;  // Default to 0 if d_value is not found
        const o1_value = parameter.o1 || 0;  // Default to 0 if o1_value is not found

        // Call displaySerialData only if the current step matches
        if (stepNo === currentStep.toString()) {
            displaySerialData(
                parameterName,
                probeNumber,
                lowMaster,
                highMaster,
                lsl,
                usl,
                ltl,
                utl,
                stepNo,
                autoMan,
                timer,
                digits,
                e_value,
                d_value,
                o1_value,
                angle
            );
        }
    

    

    const textareaId = mapProbeToTextareaId(probeNumber); // Get the textarea ID using probeNumber
    console.log("textareaId:", textareaId);
    

    const textarea = document.getElementById(textareaId);
                if (textarea) {
                    
                    textarea.addEventListener('input', function () {
                        // Get the value of the textarea and treat it as 0 if empty or invalid
                        const textareaValue = (textarea.value.trim() === '' || isNaN(parseFloat(textarea.value))) ? 0 : parseFloat(textarea.value);
                        updateAngle();
                         // Call displaySerialData with the extracted values
    if (stepNo === currentStep.toString()){
        displaySerialData(
            parameterName,
            probeNumber,
            lowMaster,
            highMaster,
            lsl,
            usl,
            ltl,
            utl,
            stepNo,
            autoMan,
            timer,
            digits,
            e_value,
            d_value,
            o1_value,
            textareaValue,
            angle,
        );
     }
});
}
    }
}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////

let displayOutputsGauge1 = [];
let displayOutputsGauge2 = [];

let stopBtnListenerAdded = false;
let dataSent = false;

function displaySerialData(parameterName, probeNumber, lowMaster, highMaster, lsl, usl, ltl, utl, stepNo, autoMan, timer, digits, e_value, d_value, o1_value, textareaValue) {
    const stepNoArray = responseData.stepNoArray;
    const channelNoArray = responseData.channelNoArray;

    const probeNumberString = probeNumber.toString();
    const stepNoString = stepNo.toString();

    const gaugeIndexMapping = [
        { gaugeIndex: 0, probeNumber: channelNoArray[0].toString(), stepNo: stepNoArray[0].toString() },
        { gaugeIndex: 1, probeNumber: channelNoArray[1].toString(), stepNo: stepNoArray[1].toString() },
    ];

    // Function to update textarea values continuously
    setInterval(() => {
        gaugeIndexMapping.forEach((mapping) => {
            if (mapping.probeNumber === probeNumberString && mapping.stepNo === stepNoString) {
                const { gaugeIndex } = mapping;
                console.log(`Processing gaugeIndex ${gaugeIndex} for Probe ${probeNumber} and Step ${stepNo}`);

                const canvasId = `gaugeCanvas${gaugeIndex + 1}`;
                const textareaId = mapProbeToTextareaId(probeNumber);
                const textarea = document.getElementById(textareaId);

                // Get the new serial data from the textarea (default to 0 if not valid)
                const newSerialData = (textarea && !isNaN(parseFloat(textarea.value))) ? parseFloat(textarea.value) : 0;
                console.log('Updated serial data from textarea:', newSerialData);

                const numericEValue = parseFloat(e_value) || 0;
                const numericDValue = parseFloat(d_value) || 0;
                const numericO1Value = parseFloat(o1_value) || 0;

                let displayOutput = numericEValue + (newSerialData * numericDValue + numericO1Value);
                displayOutput = parseFloat(displayOutput.toFixed(4));

                if (isNaN(displayOutput)) {
                    console.error("Invalid displayOutput:", displayOutput);
                    return;
                }

                if (stepNoString === currentStep.toString()) {
                    if (document.getElementById('stop-btn').innerHTML.includes("STOP")) {
                        if (gaugeIndex === 0) {
                            displayOutputsGauge1.push(displayOutput);
                        } else if (gaugeIndex === 1) {
                            displayOutputsGauge2.push(displayOutput);
                        }
                    }

                    drawGauge(canvasId, numericEValue, lsl, usl, ltl, utl, displayOutput);
                }
            }
        });
    }, 500); // Update every second

    if (currentStep === totalSteps && !stopBtnListenerAdded) {
        document.getElementById('stop-btn').addEventListener('click', handleStopBtnClick);

        window.addEventListener('keydown', function (event) {
            if (event.key === 'F5') {
                event.preventDefault();
                handleStopBtnClick();
            }
        });

        stopBtnListenerAdded = true;
    }
}

function handleStopBtnClick() {
    const ResultsArray = calculateMaxMinTir();
    console.log("TIR, MAX, MIN Results Array:", ResultsArray);

    const finalGaugeValues = [
        displayOutputsGauge1[displayOutputsGauge1.length - 1] || 0,
        displayOutputsGauge2[displayOutputsGauge2.length - 1] || 0,
    ];

    console.log("Final Gauge Values Array:", finalGaugeValues);

    const [gauge0Final, gauge1Final] = finalGaugeValues;

    const finalDecisions = [
        determineDecision(gauge0Final, ltl, lsl, usl, utl),
        determineDecision(gauge1Final, ltl, lsl, usl, utl),
    ];

    let overallStatus = "ACCEPT";
    let backgroundColor = "#0f0";

    if (finalDecisions.includes("Reject")) {
        overallStatus = "REJECT";
        backgroundColor = "red";
    } else if (finalDecisions.includes("Rework")) {
        overallStatus = "REWORK";
        backgroundColor = "yellow";
    }

    console.log("Final Overall Status:", overallStatus);

    const overallStatusInput = document.getElementById("overall_status");
    if (overallStatusInput) {
        overallStatusInput.value = overallStatus;
        overallStatusInput.style.backgroundColor = backgroundColor;
    } else {
        console.error("Overall status input field not found.");
    }

    if (!dataSent) {
        setTimeout(function () {
            DataToSend(finalGaugeValues, ResultsArray);
            dataSent = true;
        }, 1000);
    }
}



// Function to perform the calculation and update the angle dynamically
// Update function that performs the calculation
function updateAngle() {
    const Angle = responseData.angle;  
    // console.log('Your value for this Angle is:', Angle); 

    // Get the most current values of displayOutput from the gauges
    const gauge0Input = displayOutputsGauge1[displayOutputsGauge1.length - 1] || 0;
    const gauge1Input = displayOutputsGauge2[displayOutputsGauge2.length - 1] || 0;

    // console.log('Gauge 0 Display Output:', gauge0Input.toFixed(4));
    // console.log('Gauge 1 Display Output:', gauge1Input.toFixed(4));

    // --- Calculate the angle value dynamically using the latest displayOutput ---
    const oppositeSide = parseFloat(gauge0Input) - parseFloat(gauge1Input); 
    // console.log('Opposite Side Value:', oppositeSide);

    const adjacentSide = parseFloat(Angle); // Fixed adjacent side
    // console.log('Your adjacent value is:', adjacentSide);

    const out1 = oppositeSide / adjacentSide;
    // console.log('Out1 Value:', out1);

    const out2 = Math.atan(out1); // ATAN function
    // console.log('Out2 Value (Radians):', out2);

    const out3 = (out2 * 180) / Math.PI; // Convert radians to degrees
    // console.log('Out3 Value (Degrees):', out3);

    // Update the angle input field with the calculated value
    const angleInput = document.getElementById('angleInput');
    if (angleInput) {
        angleInput.value = out3.toFixed(4); // Display angle value in input box
    } else {
        console.error("Angle input box not found.");
    }
}

// Event listener for dynamically updating the angle
window.onload = function() {
    // Call the function initially to perform the calculation on page load
    updateAngle(); 

    // Set an interval to call the updateAngle function periodically (e.g., every 500ms)
    setInterval(updateAngle, 500); // Adjust the interval based on how often the values update
};



// Helper function to determine decision for a given output
function determineDecision(displayOutput, ltl, lsl, usl, utl) {
    if (displayOutput < ltl) {
        return "Reject";
    } else if (displayOutput >= ltl && displayOutput < lsl) {
        return "Rework";
    } else if (displayOutput >= lsl && displayOutput <= usl) {
        return "Accept";
    } else if (displayOutput > usl && displayOutput <= utl) {
        return "Rework";
    } else if (displayOutput > utl) {
        return "Reject";
    }
}


function DataToSend(finalGaugeValues,ResultsArray) {
    // console.log("Stored Data in function data to send finalGaugeValues:", finalGaugeValues);
    // console.log("Stored Data in function data to send ResultsArray:", ResultsArray);

    $('#loading_spinner').show();
    const overallStatusInput = document.getElementById("overall_status").value;
    const partModel = document.getElementById("part_model").value;
    const partName = document.getElementById("part_no").value;
    const date = document.getElementById("date_time").value;
    const operator = document.getElementById("operator").value;
    const shift = document.getElementById("shift").value;
    const punchNo = document.getElementById("punch_no").value;
    const angleValue = document.getElementById("angleInput").value;
    console.log('your angle value is this:',angleValue);

    const parameterName = responseData.parameterNameArray;  
    const lsl = responseData.lslArray;
    const usl = responseData.uslArray;
    const ltl = responseData.ltlArray;
    const utl = responseData.utlArray;
    const nominal = responseData.nominalArray;
    const output = finalGaugeValues;
     // Separate max, min, and tir
     const maxValues = ResultsArray.map(item => item.max);
    const minValues = ResultsArray.map(item => item.min);
    const tirValues = ResultsArray.map(item => item.tir);
       
 // Combine the common values with the array values
 let dataToSend = [];

for (let i = 0; i < 2; i++) {
    dataToSend.push({
        date: date,
        punchNo: punchNo,
        partModel: partModel,
        partName: partName,
        operator: operator,
        shift: shift,
        parameterName: parameterName[i],
        lsl: lsl[i],
        usl: usl[i],
        ltl: ltl[i],
        utl: utl[i],
        nominal: nominal[i],
        output: output[i],  // Assuming finalGaugeValues is an array of length 4
        max: maxValues[i],
        min: minValues[i],
        tir: tirValues[i],
        overallStatusInput: overallStatusInput,
        angleValue: angleValue,
    });
}
 console.log("the value which is send to the backend views.py finallllllllllllllllllllllllllllllllllllll",dataToSend)
// Send the combined data to the backend using jQuery AJAX
$.ajax({
    url: '/measure_data/', // Replace with your Django view URL
    type: 'POST',
    headers: { 'X-CSRFToken': getCSRFToken() }, // Include CSRF token
    data: JSON.stringify(dataToSend),
    contentType: 'application/json',
    success: function (response) {
        $('#loading_spinner').hide();
        console.log('Data successfully sent to the backend:', response);
        showNotification('Data successfully sent to the backend!', true);
        // Hide the notification after 3 seconds
    setTimeout(() => {
        location.reload();
    }, 1000);
    },
    error: function (error) {
        console.error('Error sending data to the backend:', error);
        showNotification('Error sending data to the backend.', false);
        $('#loading_spinner').hide();
    }
});
}


function showNotification(message, isSuccess) {
    const notifyDiv = document.querySelector('.notify');
    notifyDiv.innerHTML = message; // Set the message
    notifyDiv.style.display = 'block'; // Show the notification
    notifyDiv.style.backgroundColor = isSuccess ? 'green' : 'red'; // Set background color
    notifyDiv.style.color = 'white'; // Set text color
    notifyDiv.style.padding = '10px';
    notifyDiv.style.borderRadius = '5px';
    notifyDiv.style.marginTop = '10px';
    notifyDiv.style.textAlign = 'center';

    // Hide the notification after 3 seconds
    setTimeout(() => {
        notifyDiv.style.display = 'none';
    }, 3000);
}

  
// Helper function to get CSRF token from the browser's cookies
function getCSRFToken() {
    const csrfToken = document.cookie
        .split('; ')
        .find(row => row.startsWith('csrftoken'))
        ?.split('=')[1];
    return csrfToken;
}




function calculateMaxMinTir() {
    const results = [];

    // Function to calculate the TIR and ensure it's displayed with 4 digits
    function calculateTir(gaugeValues) {
        if (gaugeValues.length > 0) {
            const max = Math.max(...gaugeValues);
            const min = Math.min(...gaugeValues);
            const tir = (max - min) / 2;

            // Ensure the TIR is displayed with 4 digits
            return {
                max: max.toFixed(4),
                min: min.toFixed(4),
                tir: tir.toFixed(4),
            };
        } else {
            return { max: 0, min: 0, tir: 0 };
        }
    }



    // Calculate for each gauge
    const result1 = calculateTir(displayOutputsGauge1);
    const result2 = calculateTir(displayOutputsGauge2);
    console.log('your result 1 value is this:',result1);
    console.log('your result 2 value is this:',result2);


    


    // Push the results for backend without forcing the fixed format (storing original values)
    results.push(
        { max: parseFloat(result1.max), min: parseFloat(result1.min), tir: parseFloat(result1.tir) },
        { max: parseFloat(result2.max), min: parseFloat(result2.min), tir: parseFloat(result2.tir) }
    );


    return results; // Return the array of results (with values stored as floats)
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Function to map probe numbers to textarea IDs
function mapProbeToTextareaId(probeNumber) {
    const probeMapping = {
        1: "probe-A",
        2: "probe-B",
        3: "probe-C",
        4: "probe-D"
    };

    return probeMapping[probeNumber] || null; // Return null if no mapping is found
}


////////////////////////////////////////////////////////////////////////////



$(document).ready(function () {
    $("#master_btn").click(function () {
        const partName = $("#part_model").val(); // Capture the input value
        $.ajax({
            url: "/changed_name/", // URL for 'measurement' view
            method: "POST",
            headers: { "X-CSRFToken": "{{ csrf_token }}" },
            data: JSON.stringify({ part_names: partName }), // Send part_name as JSON
            contentType: "application/json", // Specify JSON content type
            success: function (response) {
                if (response.redirect_url) {
                    // Redirect to newma and send part_model as a query parameter
                    window.location.href = response.redirect_url;
                } else {
                    alert(response.message); // Show error message
                }
            },
            error: function (xhr, status, error) {
                console.error("Error:", error);
                alert("An error occurred while saving the part name.");
            },
        });
    });
});

document.addEventListener("DOMContentLoaded", function () {
        document.getElementById("report_btn").addEventListener("click", function () {
            const partName = document.getElementById("part_model").value.trim();

            if (!partName) {
                alert("Please enter a part model!");
                return;
            }

            // Redirect to the report/ page with the part_model as a query parameter
            const redirectUrl = `/report/?part_model=${encodeURIComponent(partName)}`;
            window.location.href = redirectUrl;
        });
    });


    document.addEventListener("DOMContentLoaded", function () {
        document.getElementById("spc_btn").addEventListener("click", function () {
            const partName = document.getElementById("part_model").value.trim();

            if (!partName) {
                alert("Please enter a part model!");
                return;
            }

            // Redirect to the report/ page with the part_model as a query parameter
            const redirectUrl = `/spc/?part_model=${encodeURIComponent(partName)}`;
            window.location.href = redirectUrl;
        });
    });





//////////////////////////////////////////////////////////////////
function drawGauge(canvasId, nominal, lsl, usl, ltl, utl, displayOutput) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) {
        console.error(`Canvas with ID ${canvasId} not found`);
        return;
    }

    const ctx = canvas.getContext("2d");
    const x = canvas.width / 2;
    const y = canvas.height / 2;
    const radius = Math.min(x, y) - 10; // Adjust gauge size to fit canvas

    // Clear previous content
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw the gauge background
    ctx.beginPath();
    ctx.arc(x, y, radius, 0.75 * Math.PI, 2.25 * Math.PI); // Partial arc for the background (0.75π to 2.25π)
    ctx.fillStyle = "#f0f0f0"; // Gauge background color
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#000";
    ctx.stroke();

    // Draw the arc for LSL (Lower Specification Limit) to USL (Upper Specification Limit)
    const startAngle = 0.75 * Math.PI; // Starting angle for the gauge
    const endAngle = 2.25 * Math.PI; // Ending angle for the gauge

    // Arc for LSL (Lower Specification Limit)
    ctx.beginPath();
    ctx.arc(x, y, radius, startAngle, endAngle, false); // Full arc
    ctx.lineWidth = 5;
    ctx.strokeStyle = '#ff0000'; // Color for the arc (e.g., red for LSL/USL range)
    ctx.stroke();

    // Arc for USL (Upper Specification Limit)
    ctx.beginPath();
    ctx.arc(x, y, radius, startAngle, endAngle, false); // Full arc
    ctx.lineWidth = 5;
    ctx.strokeStyle = '#00ff00'; // Color for the arc (e.g., green for USL range)
    ctx.stroke();

    // Draw the ticks and labels (optional - you can customize the drawing of ticks and labels)
    drawTicksAndLabels(ctx, x, y, radius, nominal, lsl, usl, ltl, utl);

    // Draw the needle to indicate the value
    drawNeedle(ctx, x, y, radius, nominal, lsl, usl, ltl, utl, displayOutput);

     // Pass displayOutput to drawReadingText
     drawReadingText(ctx, x, y, displayOutput,nominal, lsl, usl, ltl, utl); // Passing displayOutput
}



function drawZone(ctx, x, y, radius, startAngle, endAngle, color) {
    ctx.beginPath();
    ctx.arc(x, y, radius, startAngle, endAngle);
    ctx.lineWidth = 20;
    ctx.strokeStyle = color;
    ctx.stroke();
}

function drawTicksAndLabels(ctx, x, y, radius, nominal, lsl, usl, ltl, utl) {
    // Ensure nominal and limits are numbers
    nominal = parseFloat(nominal);
    lsl = parseFloat(lsl);
    usl = parseFloat(usl);
    ltl = parseFloat(ltl);
    utl = parseFloat(utl);

    if (
        isNaN(nominal) || 
        isNaN(lsl) || 
        isNaN(usl) || 
        isNaN(ltl) || 
        isNaN(utl)
    ) {
        console.error("Invalid values:", { nominal, lsl, usl, ltl, utl });
        return;
    }

    // Define the microns range
    const micronRange = 50;
    const minValue = nominal - micronRange / 1000;
    const maxValue = nominal + micronRange / 1000;

    // Map values to angles
    function mapToAngle(value) {
        return (
            0.75 * Math.PI + ((value - minValue) * 1.5 * Math.PI) / (maxValue - minValue)
        );
    }

    
    // Draw ticks and labels
    ctx.font = "14px Arial";
    ctx.fillStyle = "#000";
    ctx.textAlign = "center";

    for (let i = -50; i <= 50; i++) {
        const angle = 0.75 * Math.PI + ((i + 50) * 1.5 * Math.PI) / 100;
        const tickLength = i % 10 === 0 ? 20 : i % 5 === 0 ? 15 : 10; // Large, Medium, Small
        const tickWidth = i % 10 === 0 ? 3 : i % 5 === 0 ? 2 : 1; // Adjust width for visibility

        const innerTickX = x + (radius - tickLength) * Math.cos(angle);
        const innerTickY = y + (radius - tickLength) * Math.sin(angle);
        const outerTickX = x + radius * Math.cos(angle);
        const outerTickY = y + radius * Math.sin(angle);

        // Draw tick
        ctx.beginPath();
        ctx.moveTo(outerTickX, outerTickY);
        ctx.lineTo(innerTickX, innerTickY);
        ctx.lineWidth = tickWidth;
        ctx.strokeStyle = "#000";
        ctx.stroke();

        // Draw label for large ticks
        if (i % 10 === 0) {
            const labelX = x + (radius - 40) * Math.cos(angle); // Position inside the gauge
            const labelY = y + (radius - 40) * Math.sin(angle); // Position inside the gauge
            const labelValue = nominal + i / 1000; // Scale the label based on nominal
            // ctx.fillText(labelValue.toFixed(3), labelX, labelY);
            ctx.fillText(i, labelX, labelY); // Display -50 to +50 directly
        
        }
    }
}




function drawNeedle(ctx, x, y, radius, nominal, lsl, usl, ltl, utl, displayOutput = nominal) {
    // Ensure values are valid numbers before proceeding
    nominal = parseFloat(nominal);
    lsl = parseFloat(lsl);
    usl = parseFloat(usl);
    ltl = parseFloat(ltl);
    utl = parseFloat(utl);

    if (isNaN(nominal) || isNaN(lsl) || isNaN(usl) || isNaN(ltl) || isNaN(utl)) {
        console.error("Invalid values:", { nominal, lsl, usl, ltl, utl });
        return; // Exit function if any values are invalid
    }

    // Define the microns range
    const micronRange = 50;
    const minValue = nominal - micronRange / 1000;
    const maxValue = nominal + micronRange / 1000;

    // Map values to angles
    function mapToAngle(value) {
        return (
            0.75 * Math.PI + ((value - minValue) * 1.5 * Math.PI) / (maxValue - minValue)
        );
    }

    // Set default needle position if displayOutput is undefined
    if (typeof displayOutput === "undefined" || isNaN(displayOutput)) {
        displayOutput = nominal; // Default to the nominal value
    }

    // Calculate the needle angle
    const needleAngle = mapToAngle(displayOutput);
    const needleLength = radius - 20;

    // Needle tip position
    const tipX = x + needleLength * Math.cos(needleAngle);
    const tipY = y + needleLength * Math.sin(needleAngle);

    // Base of the needle
    const baseRadius = 25;
    const baseAngle1 = needleAngle - 0.2;
    const baseAngle2 = needleAngle + 0.2;

    const baseX1 = x + baseRadius * Math.cos(baseAngle1);
    const baseY1 = y + baseRadius * Math.sin(baseAngle1);
    const baseX2 = x + baseRadius * Math.cos(baseAngle2);
    const baseY2 = y + baseRadius * Math.sin(baseAngle2);

    // Rear part of the needle
    const rearX = x - 15 * Math.cos(needleAngle);
    const rearY = y - 15 * Math.sin(needleAngle);

    // Draw the needle shape
    ctx.beginPath();
    ctx.moveTo(tipX, tipY); // Tip of the needle
    ctx.lineTo(baseX1, baseY1); // Left base
    ctx.lineTo(rearX, rearY);   // Rear base
    ctx.lineTo(baseX2, baseY2); // Right base
    ctx.closePath();

    ctx.fillStyle = '#ff4500'; // Needle fill color
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#333'; // Needle border color
    ctx.stroke();

    // Draw the pivot circle at the center
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, 2 * Math.PI);
    ctx.fillStyle = '#333'; // Pivot fill color
    ctx.fill();
}



function drawReadingText(ctx, x, y, displayOutput, nominal, lsl, usl, ltl, utl, marginLeft = 15, borderWidth = 2) {
    // Ensure displayOutput is a valid number, fallback to 0 if invalid
    displayOutput = isNaN(displayOutput) ? 0 : displayOutput;
    

    // Use displayOutput for the reading value
    const readingText = `${displayOutput.toFixed(4)} MM`;

    ctx.font = '25px Arial';
    ctx.textAlign = 'center'; // Center the text horizontally
    ctx.textBaseline = 'middle'; // Vertically center the text

    // Determine background color based on displayOutput thresholds
    let backgroundColor = 'white'; // Default color
    if (displayOutput < ltl) {
        backgroundColor = '#f00'; // Red: Below LTL
    } else if (displayOutput >= ltl && displayOutput < lsl) {
        backgroundColor = '#ffd700'; // Yellow: Between LTL and LSL
    } else if (displayOutput >= lsl && displayOutput <= usl) {
        backgroundColor = '#0f0'; // Green: Between LSL and USL
    } else if (displayOutput > usl && displayOutput <= utl) {
        backgroundColor = '#ffd700'; // Yellow: Between USL and UTL
    } else if (displayOutput > utl) {
        backgroundColor = '#f00'; // Red: Above UTL
    }

    // Measure text dimensions
    const textWidth = ctx.measureText(readingText).width;
    const textHeight = 40; // Approximate height of the text

    // Draw the background with dynamic color
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(x - textWidth / 2 - 10 - marginLeft, y + 120, textWidth + 40, textHeight);

    // Border around the box
    ctx.strokeStyle = 'black'; // Border color
    ctx.lineWidth = borderWidth; // Border thickness
    ctx.strokeRect(x - textWidth / 2 - 10 - marginLeft, y + 120, textWidth + 40, textHeight);

    // Draw the actual text on top
    ctx.fillStyle = 'black';
    ctx.fillText(readingText, x - marginLeft, y + 145);
}


var shiftValues = JSON.parse('{{ shift_time|escapejs }}');
console.log('Shift values:', shiftValues);

var operator = JSON.parse('{{ user_name|escapejs }}');
console.log('operator name is this values:', operator);

if (Array.isArray(operator) && operator.length > 0) {
        document.getElementById('operator').value = operator[0].username;
    } else {
        console.error('No operator data found');
    }

    
// Function to convert 12-hour time to 24-hour format
function convertTo24Hour(timeString) {
    let [time, modifier] = timeString.trim().split(' ');
    let [hours, minutes, seconds] = time.split(':');
    if (modifier === 'PM' && hours !== '12') {
        hours = parseInt(hours, 10) + 12;
    }
    if (modifier === 'AM' && hours === '12') {
        hours = 0;
    }
    return `${hours.toString().padStart(2, '0')}:${minutes}:${seconds}`;
}

// Function to determine and update the shift name based on the current time
function setDateTimes() {
    let now = new Date();
    let currentTime = now.toTimeString().split(' ')[0]; // 'HH:MM:SS'
    let currentDate = now.toISOString().split('T')[0]; // 'YYYY-MM-DD'

    // Determine the shift based on the current time
    let shiftName = null;
    for (let i = shiftValues.length - 1; i >= 0; i--) {
        let shift = shiftValues[i];
        let shiftTime = shift.shift_time.trim();  // Trim whitespace from shift_time
        let shift24HourTime = convertTo24Hour(shiftTime);

        if (currentTime >= shift24HourTime) {
            shiftName = shift.shift;  // Set the shift name (e.g., "SHIFT-1")
            break;
        }
    }

    // If no shift is found (e.g., if the current time is before all shifts), default to the first shift
    if (!shiftName) {
        shiftName = shiftValues[0].shift; // Default to the first shift
    }

    // Set the shift name in the input box
    let fromDateElements = document.getElementsByClassName('shift-name');
    for (let element of fromDateElements) {
        element.value = shiftName;  // Set the shift name in the input box
    }


}

// Function to update the current date and time in the input box and check for shift change
function updateClock() {
    // Get the current date and time
    var currentDate = new Date();
    var hours = currentDate.getHours();
    var minutes = currentDate.getMinutes();
    var seconds = currentDate.getSeconds();
    var ampm = hours >= 12 ? 'PM' : 'AM';

    // Format the hours, minutes, and seconds
    hours = hours % 12;
    hours = hours ? hours : 12; // Handle midnight (0 hours)
    minutes = minutes < 10 ? '0' + minutes : minutes;
    seconds = seconds < 10 ? '0' + seconds : seconds;

    // Create the time string
    var currentTime = hours + ':' + minutes + ':' + seconds + ' ' + ampm;

    // Get the date components
    var day = currentDate.getDate();
    var month = currentDate.getMonth() + 1; // Month is zero-based
    var year = currentDate.getFullYear();

    // Create the date string
    var currentDateFormatted = day + '/' + month + '/' + year;

    // Set the value of the input box
    document.getElementById("date_time").value = currentDateFormatted + ' ' + currentTime;

    // Check if current time matches the next shift time
    checkShiftNotification(currentTime);

    // Call this function again after 1 second
    setTimeout(updateClock, 1000);
}

// Function to check if the current time matches the next shift time
function checkShiftNotification(currentTime) {
    let shiftTime = null;
    for (let i = 0; i < shiftValues.length; i++) {
        let shift = shiftValues[i];
        let shiftTime24Hour = convertTo24Hour(shift.shift_time);
        if (currentTime >= shiftTime24Hour) {
            shiftTime = shift.shift_time;
            break;
        }
    }

    // If shift time is found and matches the current time, show notification
    if (shiftTime && currentTime === shiftTime) {
        showShiftNotification();
    }
}

// Function to display shift change notification
function showShiftNotification() {
    let notification = document.createElement('div');
    notification.id = 'shift-notification';
    notification.innerText = 'It\'s time to switch to the next shift!';
    notification.style.position = 'fixed';
    notification.style.top = '10px';
    notification.style.right = '10px';
    notification.style.backgroundColor = 'green';
    notification.style.color = 'white';
    notification.style.padding = '10px';
    notification.style.borderRadius = '5px';
    document.body.appendChild(notification);

    // Remove the notification after 3 seconds and refresh the page
    setTimeout(function() {
        notification.style.display = 'none';
        location.reload(); // Refresh the page
    }, 3000);
}

// Call the function to initially display the clock
updateClock();

// Call setDateTimes every second to update the shift name
setInterval(setDateTimes, 1000);
        


// Initialize WebSocket connection
// Initialize WebSocket connection
const socket = new WebSocket('ws://localhost:8000/ws/measurement/');

// Variables to track data activity
let isConnected = false; // Tracks connection status
let lastMessageTime = Date.now(); // Tracks the time of the last received message
let timeoutDuration = 5000; // Set timeout duration (e.g., 5000ms = 5 seconds)

// Function to check connection status periodically
function checkConnection() {
    const currentTime = Date.now();
    const elapsedTime = currentTime - lastMessageTime;

    // Check if the elapsed time exceeds the timeout duration
    if (elapsedTime > timeoutDuration) {
        if (isConnected) {
            displayDisconnected(); // Change status to disconnected
            isConnected = false;  // Mark as disconnected
        }
    } else {
        if (!isConnected) {
            displayConnected(); // Change status to connected
            isConnected = true;  // Mark as connected
        }
    }
}

// Function to display "Connected" message
function displayConnected() {
    const messageBox = document.getElementById("message");
    messageBox.value = "Connected";
    messageBox.style.color = "black";
    messageBox.style.backgroundColor = "green";
}

// Function to display "Disconnected" message
function displayDisconnected() {
    const messageBox = document.getElementById("message");
    messageBox.value = "Disconnected";
    messageBox.style.color = "black";
    messageBox.style.backgroundColor = "red";
}

// Function to start serial communication
function startSerialCommunication() {
    const messageBox = document.getElementById("message"); // Get the input box
    if (socket.readyState === WebSocket.OPEN) {
        const dbPort = document.getElementById("db_port").value;
        const comPorts = document.getElementById("com_ports").value;
        const baudRate = document.getElementById("baud_rate").value;
        const parity = document.getElementById("parity").value;
        const stopbit = document.getElementById("stopbit").value;
        const databit = document.getElementById("databit").value;

        console.log('COM port:', comPorts);
        console.log('DB port:', dbPort);

        if (dbPort === comPorts) {
            const comparableValue = dbPort; // If equal, use dbPort
            console.log("Matching Value:", comparableValue);

            socket.send(JSON.stringify({
                command: 'start_serial',
                com_port: dbPort,
                baud_rate: baudRate,
                parity: parity,
                stopbit: stopbit,
                databit: databit,
            }));

            displayConnected(); // Initially set to connected
            lastMessageTime = Date.now(); // Reset the timer
        } else {
            displayDisconnected(); // Set to disconnected if ports don't match
        }
    } else {
        setTimeout(startSerialCommunication, 100); // Retry every 100ms if WebSocket isn't ready
    }
}

// WebSocket event listeners
socket.onopen = function(event) {
    console.log("WebSocket connection established.");
    startSerialCommunication();
};

// When data is received
socket.onmessage = function(event) {
    const data = JSON.parse(event.data);
    const message = data.message;

    // Update last message time
    lastMessageTime = Date.now();

    // Append data to textarea
    const serialDataDisplay = document.getElementById("serial-data-display");
    serialDataDisplay.value += message + '\n';
    serialDataDisplay.scrollTop = serialDataDisplay.scrollHeight;

    // Update status to connected
    displayConnected();
};

// Handle errors
socket.onerror = function(event) {
    displayDisconnected();
};

// Handle close events
socket.onclose = function(event) {
    displayDisconnected();
};

// Periodically check connection status
setInterval(checkConnection, 1000); // Check every 1 second

// jQuery WebSocket handling for COM port
$(document).ready(function () {
    const ws = new WebSocket('ws://localhost:8000/ws/comport/');

    ws.onmessage = function(event) {
        const data = JSON.parse(event.data);
        
        if (data.message) {
            lastMessageTime = Date.now(); // Reset timer when data is received

            // Match "+" pattern
            const plusChannels = data.message.match(/[A-K]\+[^\+A-K]*/g);
            if (plusChannels) {
                plusChannels.forEach(channel => {
                    const channelId = channel.charAt(0);
                    const channelData = channel.substr(2);
                    $(`#probe-${channelId}`).val(channelData);
                });
            }

            // Match "-" pattern
            const minusChannels = data.message.match(/[A-K]\-[^\-A-K]*/g);
            if (minusChannels) {
                minusChannels.forEach(channel => {
                    const channelId = channel.charAt(0);
                    const channelData = channel.substr(2);
                    $(`#probe-${channelId}`).val(channelData);
                });
            }
        }
    };
});


    </script>
    
    
</body>
</html>